{"version":3,"file":"tabtreecontainer.min.js","sources":["../../../src/courseformat/contenttabs/tabtreecontainer.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {BaseComponent} from 'core/reactive';\nimport {getCurrentCourseEditor} from 'core_courseformat/courseeditor';\nimport Tab from 'format_multitopic/courseformat/contenttabs/tab';\nimport Templates from 'core/templates';\n\n\n/**\n * Course section tabs updater.\n *\n * @module     format_multitopic/courseformat/contenttabs/tabtreecontainer\n * @class      format_multitopic/courseformat/contenttabs/tabtreecontainer\n * @copyright  2022 Jeremy FitzPatrick and Te WƒÅnanga o Aotearoa\n * @copyright  2023 onwards James Calder and Otago Polytechnic\n * @copyright  based on work by 2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nexport default class Component extends BaseComponent {\n\n    /**\n     * Constructor hook.\n     */\n    create() {\n        // Optional component name for debugging.\n        this.name = 'contenttabs';\n        // Default query selectors.\n        this.selectors = {\n            SECTIONL0: `ul:first-of-type li`,\n            SECTIONL1: `ul:nth-child(2) li`,\n            SECTION_ITEM: `a.nav-link`,\n        };\n        // Default classes\n        this.classes = {\n            ACTIVETAB: 'active'\n        };\n        // Objects to keep tabs on the tabs\n        this.sectionsl0 = {};\n        this.sectionsl1 = {};\n        this.activetab = [null, null];\n    }\n\n    static init(target) {\n        let element = document.querySelector(target);\n        return new this({\n            element,\n            reactive: getCurrentCourseEditor(),\n        });\n    }\n\n    /**\n     * Initial state ready method.\n     */\n    stateReady() {\n        this._indexContents();\n    }\n\n    getWatchers() {\n        return [\n            // Sections sorting.\n            {watch: `course.sectionlist:updated`, handler: this._refreshCourseSectionlist},\n            {watch: `course.sectionlevellist:updated`, handler: this._refreshCourseSectionlist},\n        ];\n    }\n\n    /**\n     * Get the main DOM element of this component or a subelement.\n     *\n     * @param {string|undefined} query optional subelement query\n     * @param {string|undefined} dataId optional data-id value\n     * @returns {element|undefined} the DOM element (if any)\n     */\n    getElement(query, dataId) {\n        if (dataId.match(/^add\\d*$/)) {\n            const dataSelector = `:not([data-id])`;\n            const selector = `${query ?? ''}${dataSelector}`;\n            return this.element.querySelector(selector);\n        }\n        return super.getElement(query, dataId);\n    }\n\n    /**\n     * Refresh the section tabs.\n     *\n     * @param {object} param\n     * @param {Object} param.element\n     */\n    async _refreshCourseSectionlist({element}) {\n\n        const originalPageSectionid = this.reactive?.pageSectionId\n                                        ?? document.querySelector(\"ul.section-list\").dataset.originalsinglesectionid;\n                                        // Fallback deprecated since Moodle 5.1 MDL-83857.\n        const originalPageSection = this.reactive.get(\"section\", originalPageSectionid);\n        let pageSectionId;\n        let pageSection;\n        if (originalPageSection) {\n            pageSectionId = (originalPageSection.levelsan < 2) ? originalPageSection.id : originalPageSection.pageid;\n            pageSection = (pageSectionId == originalPageSection.id) ?\n                            originalPageSection : this.reactive.get(\"section\", pageSectionId);\n        } else {\n            pageSectionId = null;\n            pageSection = null;\n        }\n\n        let newActiveTab = [null, null];\n        if (pageSection) {\n            newActiveTab[1] = pageSection.id;\n            newActiveTab[0] = (pageSection.levelsan >= 1) ? pageSection.parentid : pageSection.id;\n        }\n\n        const tabsrow = this._getTabRows(element, newActiveTab);\n\n        if (!tabsrow[1].length) {\n            newActiveTab[1] = null;\n        }\n\n        // Remove second-level tabs, if necessary.\n        let tabsSecondRowDom = this.element.querySelector('ul:nth-of-type(2)');\n        if (tabsSecondRowDom && (!tabsrow[1].length || (newActiveTab[0] != this.activetab[0]))) {\n            tabsSecondRowDom.remove();\n            tabsSecondRowDom = null;\n            this.activetab[1] = null;\n        }\n\n        // Update the tabs.\n        for (let level = 0; level < 2; level++) {\n            if (tabsrow[level].length) {\n                let tabsDom = this.element.querySelector('ul:nth-of-type(' + (level + 1) + ')');\n                // Create tab row if necessary.\n                if (!tabsDom) {\n                    tabsDom = document.createElement('ul');\n                    this.element.append(tabsDom);\n                    tabsDom.className = 'nav nav-tabs mb-3';\n                }\n                // Unselect old tab.\n                if (this.activetab[level] && (newActiveTab[level] != this.activetab[level])) {\n                    tabsDom.querySelector('div[data-itemid=\"' + this.activetab[level] + '\"]')\n                            ?.parentElement.classList.remove(\"active\");\n                    this.activetab[level] = null;\n                }\n                // Update tabs order.\n                await this._fixOrder(tabsDom, tabsrow[level], level ? this.selectors.SECTIONL1 : this.selectors.SECTIONL0, level);\n                // Select new tab.\n                if (newActiveTab[level]) {\n                    this.activetab[level] = newActiveTab[level];\n                    tabsDom.querySelector('div[data-itemid=\"' + this.activetab[level] + '\"]')\n                            ?.parentElement.classList.add(\"active\");\n                }\n            }\n            this.activetab[level] = newActiveTab[level];\n        }\n\n        this._indexContents();\n    }\n\n    /**\n     * Get tab rows.\n     *\n     * @param {Object} element\n     * @param {Array} newActiveTab\n     * @returns {Array}\n     */\n    _getTabRows(element, newActiveTab) {\n        let tabsrow = [[], []];\n        let depthmax = -1;\n        let depthactive = -1;\n\n        for (let sectionid of element.sectionlist) {\n            const section = this.reactive.get(\"section\", sectionid);\n            if (section.component || (section.levelsan >= 2)) {\n                continue;\n            }\n            if ((section.levelsan < 0) || (section.id == newActiveTab[section.levelsan])) {\n                for (\n                    let level = section.levelsan;\n                    (level < 2) && ((level < 0) || (section.id == newActiveTab[level]));\n                    level++\n                ) {\n                    depthactive = level;\n                }\n            } else {\n                depthactive = Math.min(depthactive, section.levelsan - 1);\n            }\n            if ((section.levelsan >= 0) && (section.levelsan <= depthactive + 1)) {\n                tabsrow[section.levelsan].push(section.id);\n                depthmax = Math.max(depthmax, section.levelsan);\n            }\n        }\n\n        for (let level = 0; level <= Math.min(depthmax + 1, 1); level++) {\n            const parentid = (level == 0) ? element.sectionlist[0] : newActiveTab[level - 1];\n            tabsrow[level].unshift(parentid);\n            tabsrow[level].push(\"add\" + parentid);\n        }\n\n        return tabsrow;\n    }\n\n    /**\n     * Regenerate content indexes.\n     *\n     * This method is used when a legacy action refresh some content element.\n     */\n    _indexContents() {\n        // Find unindexed tabs.\n        this._scanIndex(\n            this.selectors.SECTIONL0,\n            this.sectionsl0,\n            (item) => {\n                return new Tab(item);\n            },\n            0\n        );\n\n        // Find unindexed child tabs.\n        this._scanIndex(\n            this.selectors.SECTIONL1,\n            this.sectionsl1,\n            (item) => {\n                return new Tab(item);\n            },\n            1\n        );\n    }\n\n    /**\n     * Reindex a tab.\n     *\n     * This method is used internally by _indexContents.\n     *\n     * @param {string} selector the DOM selector to scan\n     * @param {*} index the index attribute to update\n     * @param {*} creationhandler method to create a new indexed element\n     * @param {int} level tab level\n     */\n    _scanIndex(selector, index, creationhandler, level) {\n        const items = this.getElements(`${selector}:not([data-indexed])`);\n        items.forEach((item) => {\n            if (!item?.dataset?.id) {\n                return;\n            }\n            // Delete previous item component.\n            if (index[item.dataset.id] !== undefined) {\n                index[item.dataset.id].unregister();\n            }\n            // Create the new component.\n            index[item.dataset.id] = creationhandler({\n                ...this,\n                element: item,\n            });\n            // Update selected tab\n            let classes = item.querySelector(\"a\").classList;\n            if (classes.contains(this.classes.ACTIVETAB)) {\n                this.activetab[level] = item.dataset.id;\n            }\n            // Mark as indexed.\n            item.dataset.indexed = true;\n        });\n    }\n\n    /**\n     * Create a new section item.\n     *\n     * This method will append a new item in the container.\n     *\n     * @param {Element} container the container element (section)\n     * @param {Number} sectionid the course-module ID\n     * @param {int} level the tab level\n     * @returns {Element} the created element\n     */\n    async _createSectionItem(container, sectionid, level) {\n        let data;\n        if (!isNaN(parseInt(sectionid))) {\n            const section = this.reactive.get(\"section\", sectionid);\n            const visible = (section.visible && section.available || (section.section == 0)) && (level <= section.pagedepthdirect);\n            const current = (section.currentnestedlevel != undefined) && (section.currentnestedlevel >= level);\n            data = {\n                \"sectionid\": section.id,\n                \"level\": level,\n                \"active\": 0,\n                \"inactive\": 0,\n                \"link\": [{\n                    \"link\": section.sectionurl\n                }],\n                \"title\": section.name,\n                \"text\": '<div class=\"tab_content' + (visible ? '' : ' dimmed') + (current ? ' marker' : '')\n                    + '\" data-itemid=\"' + section.id + '\">' + section.title + '</div>'\n            };\n        } else {\n            const addTab0Dom = this.element.querySelector('ul:first-of-type li:last-of-type');\n            data = {\n                \"level\": level,\n                \"active\": false,\n                \"inactive\": addTab0Dom.querySelector('a').classList.contains(\"disabled\"),\n                \"link\": [{\n                    \"link\": addTab0Dom.querySelector('a').getAttribute('href')\n                        ?.replace(/\\binsertparentid=\\d+\\b/, \"insertparentid=\" + sectionid.match(/^add(\\d+)$/)[1])\n                        .replace(/\\binsertlevel=0\\b/, 'insertlevel=' + level),\n                }],\n                \"title\": addTab0Dom.querySelector('a').getAttribute('title'),\n                \"text\": '<i class=\"icon fa fa-plus fa-fw\" title=\"' + addTab0Dom.querySelector('a').getAttribute('title') + '\"></i>',\n            };\n        }\n        let newItem = document.createElement(\"li\");\n        const {html} = await Templates.renderForPromise(\"format_multitopic/courseformat/contenttabs/tab\", data);\n        newItem = Templates.replaceNode(newItem, html, \"\")[0];\n        return newItem;\n    }\n\n    /**\n     * Fix/reorder the section or cms order.\n     *\n     * @param {Element} container the HTML element to reorder.\n     * @param {Array} neworder an array with the ids order\n     * @param {string} selector the element selector\n     * @param {int} level the tab level\n     */\n    async _fixOrder(container, neworder, selector, level) {\n\n        // Empty lists should not be visible.\n        if (!neworder.length) {\n            container.classList.add('hidden');\n            container.innerHTML = '';\n            return;\n        }\n\n        // Grant the list is visible (in case it was empty).\n        container.classList.remove('hidden');\n\n        // Move the elements in order at the beginning of the list.\n        for (const [index, itemid] of Object.entries(neworder)) {\n            let item = this.getElement(selector, itemid) ?? await this._createSectionItem(container, itemid, level);\n\n            // Get the current element at that position.\n            const currentitem = container.children[index];\n            if (currentitem === undefined) {\n                container.append(item);\n            } else if (currentitem !== item) {\n                container.insertBefore(item, currentitem);\n            }\n        }\n\n        // Remove the remaining elements.\n        while (container.children.length > neworder.length) {\n            container.removeChild(container.lastChild);\n        }\n\n    }\n\n}"],"names":["Component","BaseComponent","create","name","selectors","SECTIONL0","SECTIONL1","SECTION_ITEM","classes","ACTIVETAB","sectionsl0","sectionsl1","activetab","target","this","element","document","querySelector","reactive","stateReady","_indexContents","getWatchers","watch","handler","_refreshCourseSectionlist","getElement","query","dataId","match","dataSelector","selector","super","originalPageSectionid","_this$reactive","pageSectionId","dataset","originalsinglesectionid","originalPageSection","get","pageSection","levelsan","id","pageid","newActiveTab","parentid","tabsrow","_getTabRows","length","tabsSecondRowDom","remove","level","tabsDom","createElement","append","className","parentElement","classList","_fixOrder","add","depthmax","depthactive","sectionid","sectionlist","section","component","Math","min","push","max","unshift","_scanIndex","item","Tab","index","creationhandler","getElements","forEach","_item$dataset","undefined","unregister","contains","indexed","container","data","isNaN","parseInt","addTab0Dom","getAttribute","_addTab0Dom$querySele","replace","visible","available","pagedepthdirect","current","currentnestedlevel","sectionurl","title","newItem","html","Templates","renderForPromise","replaceNode","neworder","innerHTML","itemid","Object","entries","_createSectionItem","currentitem","children","insertBefore","removeChild","lastChild"],"mappings":"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"}