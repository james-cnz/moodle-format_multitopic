{"version":3,"file":"tabtree.min.js","sources":["../../../src/courseformat/contenttabs/tabtree.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {BaseComponent} from 'core/reactive';\nimport {getCurrentCourseEditor} from 'core_courseformat/courseeditor';\nimport Tab from 'format_multitopic/courseformat/contenttabs/tab';\nimport Templates from 'core/templates';\n\n\n/**\n * Course section tabs updater.\n *\n * @module     format_multitopic/courseformat/contenttabs/tabtree\n * @class      format_multitopic/courseformat/contenttabs/tabtree\n * @copyright  2022 Jeremy FitzPatrick and Te WƒÅnanga o Aotearoa\n * @copyright  2023 James Calder and Otago Polytechnic\n * @copyright  based on work by 2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nexport default class Component extends BaseComponent {\n\n    /**\n     * Constructor hook.\n     */\n    create() {\n        // Optional component name for debugging.\n        this.name = 'contenttabs';\n        // Default query selectors.\n        this.selectors = {\n            TAB: `ul:first-of-type li`,\n            CHILDTAB: `ul:nth-child(2) li`,\n            SECTION_ITEM: `a.nav-link`,\n        };\n        // Default classes\n        this.classes = {\n            ACTIVETAB: 'active'\n        };\n        // Objects to keep tabs on the tabs\n        this.tabs = {};\n        this.childtabs = {};\n        this.activetab = [null, null];\n    }\n\n    static init(target) {\n        return new this({\n            element: document.getElementById(target),\n            reactive: getCurrentCourseEditor(),\n        });\n    }\n\n    /**\n     * Initial state ready method.\n     *\n     */\n    stateReady() {\n        this._indexContents();\n    }\n\n    getWatchers() {\n        return [\n            // Sections sorting.\n            {watch: `course.sectionlist:updated`, handler: this._refreshCourseSectionTabs},\n        ];\n    }\n\n    /**\n     * Refresh the section tabs.\n     *\n     * @param {object} param\n     * @param {Object} param.element\n     */\n    async _refreshCourseSectionTabs({element}) {\n\n        // Add/remove the second-level tabs, if necessary.\n        let tabsSecondRowDom = this.element.querySelector('ul:nth-of-type(2)');\n        const tabsSecondRowShow = (element.firstsectionlist.length > 1) || (element.secondsectionlist.length > 1);\n        if (tabsSecondRowShow && !tabsSecondRowDom) {\n            // Create tab row.\n            this.element.querySelector('ul:first-of-type').insertAdjacentElement(\n                'afterend', tabsSecondRowDom = document.createElement('ul')\n            );\n            tabsSecondRowDom.className = 'nav nav-tabs mb-3';\n            // Create index tab.\n            const activeTab0Dom = this.element.querySelector('ul:first-of-type li:first-of-type');\n            let data = {\n                \"sectionid\": activeTab0Dom.dataset.id,\n                \"level\": 1,\n                \"active\": true,\n                \"inactive\": true,\n                \"title\": activeTab0Dom.getAttribute('title'),\n                \"text\": '<div class=\"tab_content dimmed\" data-itemid=\"' + activeTab0Dom.dataset.id + '\">'\n                        + activeTab0Dom.getAttribute('title') + '</div>',\n            };\n            let item = document.createElement(\"li\");\n            tabsSecondRowDom.insertAdjacentElement('afterstart', item);\n            let html = await Templates.render(\"format_multitopic/courseformat/contenttabs/tab\", data);\n            item = Templates.replaceNode(item, html, \"\")[0];\n            // Create add tab.\n            const addTab0Dom = this.element.querySelector('ul:first-of-type li:last-of-type');\n            data = {\n                \"level\": 1,\n                \"active\": false,\n                \"inactive\": false,\n                \"link\": [{\n                    \"link\": addTab0Dom.querySelector('a').getAttribute('href').replace(/\\binsertlevel=0\\b/, 'insertlevel=1'),\n                }],\n                \"title\": addTab0Dom.getAttribute('title'),\n                \"text\": '<i class=\"icon fa fa-plus fa-fw\" title=\"' + activeTab0Dom.getAttribute('title') + '\"></i>',\n            };\n            item = document.createElement(\"li\");\n            tabsSecondRowDom.insertAdjacentElement('beforeend', item);\n            html = await Templates.render(\"format_multitopic/courseformat/contenttabs/tab\", data);\n            item = Templates.replaceNode(item, html, \"\")[0];\n        } else if (tabsSecondRowDom && !tabsSecondRowShow) {\n            tabsSecondRowDom.remove();\n        }\n\n        // Change the active top-level tab, if necessary.\n        const activeTab1 = this.reactive.get('section', this.activetab[1]);\n        let newActiveTab0id = (activeTab1.levelsan >= 1) ? activeTab1.parentid : activeTab1.id;\n        if (newActiveTab0id != this.activetab[0]) {\n            let section = this.reactive.get(\"section\", this.activetab[0]);\n            let anchor = this.element.querySelector('ul:first-of-type div[data-itemid=\"' + this.activetab[0] + '\"]').parentElement;\n            anchor.classList.remove(\"active\");\n            anchor.href = section.sectionurl.replace(\"&amp;\", \"&\");\n            this.activetab[0] = newActiveTab0id;\n            anchor = this.element.querySelector('ul:first-of-type div[data-itemid=\"' + this.activetab[0] + '\"]').parentElement;\n            anchor.classList.add(\"active\");\n            anchor.removeAttribute(\"href\");\n            const addAnchor = this.element.querySelector('ul:nth-of-type(2) li:last-of-type a');\n            const addLink = addAnchor.href.replace(/\\binsertparentid=\\d+\\b/, \"insertparentid=\" + this.activetab[0]);\n            addAnchor.setAttribute(\"href\", addLink);\n        }\n\n        // Do things that make the first row tabs match firstsectionlist.\n        const toptabslist = element.firstsectionlist ?? [];\n        const childtabslist = element.secondsectionlist ?? [];\n        let toptabs = this.element.querySelector('ul:first-of-type');\n        await this._fixOrder(toptabs, toptabslist, this.selectors.TAB, 0, childtabslist[this.activetab[0]].length > 1);\n\n        // And the second row tabs match secondsectionlist.\n        let childtabs = this.element.querySelector('ul:nth-of-type(2)');\n        if (childtabs) {\n            await this._fixOrder(childtabs, childtabslist[this.activetab[0]], this.selectors.CHILDTAB, 1, false);\n        }\n\n        this._indexContents();\n    }\n\n    /**\n     * Regenerate content indexes.\n     *\n     * This method is used when a legacy action refresh some content element.\n     */\n    _indexContents() {\n        // Find unindexed tabs.\n        this._scanIndex(\n            this.selectors.TAB,\n            this.tabs,\n            (item) => {\n                return new Tab(item);\n            },\n            0\n        );\n\n        // Find unindexed child tabs.\n        this._scanIndex(\n            this.selectors.CHILDTAB,\n            this.childtabs,\n            (item) => {\n                return new Tab(item);\n            },\n            1\n        );\n    }\n\n    /**\n     * Reindex a tab.\n     *\n     * This method is used internally by _indexContents.\n     *\n     * @param {string} selector the DOM selector to scan\n     * @param {*} index the index attribute to update\n     * @param {*} creationhandler method to create a new indexed element\n     * @param {int} level tab level\n     */\n    _scanIndex(selector, index, creationhandler, level) {\n        const items = this.getElements(`${selector}:not([data-indexed])`);\n        items.forEach((item) => {\n            if (!item?.dataset?.id) {\n                return;\n            }\n            // Delete previous item component.\n            if (index[item.dataset.id] !== undefined) {\n                index[item.dataset.id].unregister();\n            }\n            // Create the new component.\n            index[item.dataset.id] = creationhandler({\n                ...this,\n                element: item,\n            });\n            // Update selected tab\n            let classes = item.querySelector(\"a\").classList.value;\n            if (classes.indexOf(this.classes.ACTIVETAB) !== -1) {\n                if (level <= 0) {\n                    this.activetab[0] = item.dataset.id;\n                }\n                this.activetab[1] = item.dataset.id;\n            }\n            // Mark as indexed.\n            item.dataset.indexed = true;\n        });\n    }\n\n    /**\n     * Fix/reorder the section or cms order.\n     *\n     * @param {Element} container the HTML element to reorder.\n     * @param {Array} neworder an array with the ids order\n     * @param {string} selector the element selector\n     * @param {int} level the tab level\n     * @param {boolean} hassubtree\n     */\n    async _fixOrder(container, neworder, selector, level, hassubtree) {\n\n        // Empty lists should not be visible.\n        if (!neworder.length) {\n            container.classList.add('hidden');\n            container.innerHTML = '';\n            return;\n        }\n\n        // Grant the list is visible (in case it was empty).\n        container.classList.remove('hidden');\n\n        // Move the elements in order at the beginning of the list.\n        for (const [index, itemid] of Object.entries(neworder)) {\n            const section = this.reactive.get(\"section\", itemid);\n            const visible = (section.visible && section.available || section.section == 0)\n                && (neworder.length > 1 || hassubtree);\n            const current = (section.currentnestedlevel != undefined && section.currentnestedlevel >= level);\n            let item = this.getElement(selector, itemid);\n            if (item === null) {\n                // If we don't have an item, create it.\n                let data = {\n                    \"sectionid\": itemid,\n                    \"level\": level,\n                    \"active\": 0,\n                    \"inactive\": 0,\n                    \"link\": [{\n                        \"link\": section.sectionurl\n                    }],\n                    \"title\": section.name,\n                    \"text\": '<div class=\"tab_content' + (visible ? '' : ' dimmed') + (current ? ' marker' : '')\n                        + '\" data-itemid=\"' + section.id + '\">' + section.title + '</div>'\n                };\n                item = document.createElement(\"li\");\n                container.insertBefore(item, container.lastElementChild);\n                let html = await Templates.render(\"format_multitopic/courseformat/contenttabs/tab\", data);\n                item = Templates.replaceNode(item, html, \"\")[0];\n            }\n\n            // Update visibility & current marker\n            const content = item.querySelector(\"div.tab_content\");\n            if (content && content.classList.contains(\"dimmed\") == visible) {\n                if (visible) {\n                    content.classList.remove(\"dimmed\");\n                } else {\n                    content.classList.add(\"dimmed\");\n                }\n            }\n            if (content && content.classList.contains(\"marker\") != current) {\n                if (current) {\n                    content.classList.add(\"marker\");\n                } else {\n                    content.classList.remove(\"marker\");\n                }\n            }\n\n            // Get the current element at that position.\n            const currentitem = container.children[index];\n            if (currentitem === undefined) {\n                container.append(item);\n                return;\n            }\n            if (currentitem !== item) {\n                container.insertBefore(item, currentitem);\n            }\n        }\n        // Remove the remaining elements.\n        // But we don't want the \"Add\" blown away.\n        while (container.children.length > neworder.length + 1) {\n                container.removeChild(container.lastElementChild.previousSibling);\n        }\n\n    }\n\n}"],"names":["Component","BaseComponent","create","name","selectors","TAB","CHILDTAB","SECTION_ITEM","classes","ACTIVETAB","tabs","childtabs","activetab","target","this","element","document","getElementById","reactive","stateReady","_indexContents","getWatchers","watch","handler","_refreshCourseSectionTabs","tabsSecondRowDom","querySelector","tabsSecondRowShow","firstsectionlist","length","secondsectionlist","insertAdjacentElement","createElement","className","activeTab0Dom","data","dataset","id","getAttribute","item","html","Templates","render","replaceNode","addTab0Dom","replace","remove","activeTab1","get","newActiveTab0id","levelsan","parentid","section","anchor","parentElement","classList","href","sectionurl","add","removeAttribute","addAnchor","addLink","setAttribute","toptabslist","childtabslist","toptabs","_fixOrder","_scanIndex","Tab","selector","index","creationhandler","level","getElements","forEach","_item$dataset","undefined","unregister","value","indexOf","indexed","container","neworder","hassubtree","innerHTML","itemid","Object","entries","visible","available","current","currentnestedlevel","getElement","title","insertBefore","lastElementChild","content","contains","currentitem","children","append","removeChild","previousSibling"],"mappings":";;;;;;;;;;2KAgCqBA,kBAAkBC,wBAKnCC,cAESC,KAAO,mBAEPC,UAAY,CACbC,0BACAC,8BACAC,gCAGCC,QAAU,CACXC,UAAW,eAGVC,KAAO,QACPC,UAAY,QACZC,UAAY,CAAC,KAAM,kBAGhBC,eACD,IAAIC,KAAK,CACZC,QAASC,SAASC,eAAeJ,QACjCK,UAAU,4CAQlBC,kBACSC,iBAGTC,oBACW,CAEH,CAACC,mCAAqCC,QAAST,KAAKU,sHAU5BT,QAACA,cAGzBU,iBAAmBX,KAAKC,QAAQW,cAAc,2BAC5CC,kBAAqBZ,QAAQa,iBAAiBC,OAAS,GAAOd,QAAQe,kBAAkBD,OAAS,KACnGF,oBAAsBF,iBAAkB,MAEnCV,QAAQW,cAAc,oBAAoBK,sBAC3C,WAAYN,iBAAmBT,SAASgB,cAAc,OAE1DP,iBAAiBQ,UAAY,0BAEvBC,cAAgBpB,KAAKC,QAAQW,cAAc,yCAC7CS,KAAO,WACMD,cAAcE,QAAQC,SAC1B,UACC,YACE,QACHH,cAAcI,aAAa,cAC5B,gDAAkDJ,cAAcE,QAAQC,GAAK,KAC3EH,cAAcI,aAAa,SAAW,UAEhDC,KAAOvB,SAASgB,cAAc,MAClCP,iBAAiBM,sBAAsB,aAAcQ,UACjDC,WAAaC,mBAAUC,OAAO,iDAAkDP,MACpFI,KAAOE,mBAAUE,YAAYJ,KAAMC,KAAM,IAAI,SAEvCI,WAAa9B,KAAKC,QAAQW,cAAc,oCAC9CS,KAAO,OACM,UACC,YACE,OACJ,CAAC,MACGS,WAAWlB,cAAc,KAAKY,aAAa,QAAQO,QAAQ,oBAAqB,yBAEnFD,WAAWN,aAAa,cACzB,2CAA6CJ,cAAcI,aAAa,SAAW,UAE/FC,KAAOvB,SAASgB,cAAc,MAC9BP,iBAAiBM,sBAAsB,YAAaQ,MACpDC,WAAaC,mBAAUC,OAAO,iDAAkDP,MAChFI,KAAOE,mBAAUE,YAAYJ,KAAMC,KAAM,IAAI,QACtCf,mBAAqBE,mBAC5BF,iBAAiBqB,eAIfC,WAAajC,KAAKI,SAAS8B,IAAI,UAAWlC,KAAKF,UAAU,QAC3DqC,gBAAmBF,WAAWG,UAAY,EAAKH,WAAWI,SAAWJ,WAAWV,MAChFY,iBAAmBnC,KAAKF,UAAU,GAAI,KAClCwC,QAAUtC,KAAKI,SAAS8B,IAAI,UAAWlC,KAAKF,UAAU,IACtDyC,OAASvC,KAAKC,QAAQW,cAAc,qCAAuCZ,KAAKF,UAAU,GAAK,MAAM0C,cACzGD,OAAOE,UAAUT,OAAO,UACxBO,OAAOG,KAAOJ,QAAQK,WAAWZ,QAAQ,QAAS,UAC7CjC,UAAU,GAAKqC,gBACpBI,OAASvC,KAAKC,QAAQW,cAAc,qCAAuCZ,KAAKF,UAAU,GAAK,MAAM0C,cACrGD,OAAOE,UAAUG,IAAI,UACrBL,OAAOM,gBAAgB,cACjBC,UAAY9C,KAAKC,QAAQW,cAAc,uCACvCmC,QAAUD,UAAUJ,KAAKX,QAAQ,yBAA0B,kBAAoB/B,KAAKF,UAAU,IACpGgD,UAAUE,aAAa,OAAQD,eAI7BE,0CAAchD,QAAQa,wEAAoB,GAC1CoC,4CAAgBjD,QAAQe,yEAAqB,OAC/CmC,QAAUnD,KAAKC,QAAQW,cAAc,0BACnCZ,KAAKoD,UAAUD,QAASF,YAAajD,KAAKV,UAAUC,IAAK,EAAG2D,cAAclD,KAAKF,UAAU,IAAIiB,OAAS,OAGxGlB,UAAYG,KAAKC,QAAQW,cAAc,qBACvCf,iBACMG,KAAKoD,UAAUvD,UAAWqD,cAAclD,KAAKF,UAAU,IAAKE,KAAKV,UAAUE,SAAU,GAAG,QAG7Fc,iBAQTA,sBAES+C,WACDrD,KAAKV,UAAUC,IACfS,KAAKJ,MACJ6B,MACU,IAAI6B,aAAI7B,OAEnB,QAIC4B,WACDrD,KAAKV,UAAUE,SACfQ,KAAKH,WACJ4B,MACU,IAAI6B,aAAI7B,OAEnB,GAcR4B,WAAWE,SAAUC,MAAOC,gBAAiBC,OAC3B1D,KAAK2D,sBAAeJ,kCAC5BK,SAASnC,4BACNA,MAAAA,4BAAAA,KAAMH,mCAANuC,cAAetC,eAIWuC,IAA3BN,MAAM/B,KAAKH,QAAQC,KACnBiC,MAAM/B,KAAKH,QAAQC,IAAIwC,aAG3BP,MAAM/B,KAAKH,QAAQC,IAAMkC,gBAAgB,IAClCzD,KACHC,QAASwB,QAIoC,IADnCA,KAAKb,cAAc,KAAK6B,UAAUuB,MACpCC,QAAQjE,KAAKN,QAAQC,aACzB+D,OAAS,SACJ5D,UAAU,GAAK2B,KAAKH,QAAQC,SAEhCzB,UAAU,GAAK2B,KAAKH,QAAQC,IAGrCE,KAAKH,QAAQ4C,SAAU,qBAafC,UAAWC,SAAUb,SAAUG,MAAOW,gBAG7CD,SAASrD,cACVoD,UAAU1B,UAAUG,IAAI,eACxBuB,UAAUG,UAAY,IAK1BH,UAAU1B,UAAUT,OAAO,cAGtB,MAAOwB,MAAOe,UAAWC,OAAOC,QAAQL,UAAW,OAC9C9B,QAAUtC,KAAKI,SAAS8B,IAAI,UAAWqC,QACvCG,SAAWpC,QAAQoC,SAAWpC,QAAQqC,WAAgC,GAAnBrC,QAAQA,WACzD8B,SAASrD,OAAS,GAAKsD,YACzBO,QAAyCd,MAA9BxB,QAAQuC,oBAAmCvC,QAAQuC,oBAAsBnB,UACtFjC,KAAOzB,KAAK8E,WAAWvB,SAAUgB,WACxB,OAAT9C,KAAe,KAEXJ,KAAO,WACMkD,aACJb,aACC,WACE,OACJ,CAAC,MACGpB,QAAQK,mBAEXL,QAAQjD,UACT,2BAA6BqF,QAAU,GAAK,YAAcE,QAAU,UAAY,IAClF,kBAAoBtC,QAAQf,GAAK,KAAOe,QAAQyC,MAAQ,UAElEtD,KAAOvB,SAASgB,cAAc,MAC9BiD,UAAUa,aAAavD,KAAM0C,UAAUc,sBACnCvD,WAAaC,mBAAUC,OAAO,iDAAkDP,MACpFI,KAAOE,mBAAUE,YAAYJ,KAAMC,KAAM,IAAI,SAI3CwD,QAAUzD,KAAKb,cAAc,mBAC/BsE,SAAWA,QAAQzC,UAAU0C,SAAS,WAAaT,UAC/CA,QACAQ,QAAQzC,UAAUT,OAAO,UAEzBkD,QAAQzC,UAAUG,IAAI,WAG1BsC,SAAWA,QAAQzC,UAAU0C,SAAS,WAAaP,UAC/CA,QACAM,QAAQzC,UAAUG,IAAI,UAEtBsC,QAAQzC,UAAUT,OAAO,iBAK3BoD,YAAcjB,UAAUkB,SAAS7B,eACnBM,IAAhBsB,wBACAjB,UAAUmB,OAAO7D,MAGjB2D,cAAgB3D,MAChB0C,UAAUa,aAAavD,KAAM2D,kBAK9BjB,UAAUkB,SAAStE,OAASqD,SAASrD,OAAS,GAC7CoD,UAAUoB,YAAYpB,UAAUc,iBAAiBO"}