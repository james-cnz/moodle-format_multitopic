{"version":3,"file":"mutations.min.js","sources":["../../../src/courseformat/courseeditor/mutations.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Format Multitopic mutations.\n *\n * An instance of this class will be used to add custom mutations to the course editor.\n * To make sure the addMutations method find the proper functions, all functions must\n * be declared as class attributes, not a simple methods. The reason is because many\n * plugins can add extra mutations to the course editor.\n *\n * @module     format_multitopic/courseformat/courseeditor/mutations\n * @copyright  2022 onwards James Calder and Otago Polytechnic\n * @copyright  based on work by 2021 onwards Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport ajax from 'core/ajax';\nimport {getCurrentCourseEditor} from 'core_courseformat/courseeditor';\nimport DefaultMutations from 'core_courseformat/local/courseeditor/mutations';\nimport CourseActions from 'core_courseformat/local/content/actions';\n\nclass MultitopicMutations extends DefaultMutations {\n\n    /**\n     * Private method to call core_courseformat_update_course webservice.\n     *\n     * @method _callEditWebservice\n     * @param {string} action\n     * @param {number} courseId\n     * @param {array} ids\n     * @param {number} targetSectionId optional target section id (for moving actions)\n     * @param {number} targetCmId optional target cm id (for moving actions)\n     */\n    async _callEditWebservice(action, courseId, ids, targetSectionId, targetCmId) {\n        const args = {\n            action,\n            courseid: courseId,\n            ids,\n        };\n        if (targetSectionId) {\n            args.targetsectionid = targetSectionId;\n        }\n        if (targetCmId !== undefined) { // CHANGED.\n            args.targetcmid = targetCmId;\n        }\n        let ajaxresult = await ajax.call([{\n            methodname: 'core_courseformat_update_course',\n            args,\n        }])[0];\n        return JSON.parse(ajaxresult);\n    }\n\n    /**\n     * Move course sections after a specific course location.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids to move\n     * @param {number} targetSectionId the target section id\n     */\n    sectionMoveAfter = async function(stateManager, sectionIds, targetSectionId) {\n        if (!targetSectionId) {\n            throw new Error(`Mutation sectionMoveAfter requires targetSectionId`);\n        }\n        const course = stateManager.get('course');\n        // ADDED.\n        let subsectionIds = [];\n        for (const sectionId of sectionIds) {\n            const section = stateManager.get(\"section\", sectionId);\n            for (let subsection = section;\n                    subsection && (subsection.id == section.id || subsection.levelsan > section.levelsan);\n                    subsection = (course.sectionlist.length > subsection.number + 1) ?\n                        stateManager.get(\"section\", course.sectionlist[subsection.number + 1]) : null) {\n                subsectionIds.push(subsection.id);\n            }\n        }\n        // END ADDED.\n        this.sectionLock(stateManager, subsectionIds, true);\n        const updates = await this._callEditWebservice('section_move_after', course.id, sectionIds, targetSectionId);\n        if (typeof this.bulkReset === \"function\") {\n            this.bulkReset(stateManager);\n        }\n        stateManager.processUpdates(updates);\n        this.sectionLock(stateManager, subsectionIds, false);\n    };\n\n    /**\n     * Move course sections into a specific course location.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids to move\n     * @param {number} targetSectionId the target section id\n     */\n    fmtSectionMoveInto = async function(stateManager, sectionIds, targetSectionId) {\n        if (!targetSectionId) {\n            throw new Error(`Mutation sectionMoveInto requires targetSectionId`);\n        }\n        const course = stateManager.get('course');\n        // ADDED.\n        let subsectionIds = [];\n        for (const sectionId of sectionIds) {\n            const section = stateManager.get(\"section\", sectionId);\n            for (let subsection = section;\n                    subsection && (subsection.id == section.id || subsection.levelsan > section.levelsan);\n                    subsection = (course.sectionlist.length > subsection.number + 1) ?\n                        stateManager.get(\"section\", course.sectionlist[subsection.number + 1]) : null) {\n                subsectionIds.push(subsection.id);\n            }\n        }\n        // END ADDED.\n        this.sectionLock(stateManager, subsectionIds, true);\n        const updates = await this._callEditWebservice('fmt_section_move_into', course.id, sectionIds, targetSectionId);\n        if (typeof this.bulkReset === \"function\") {\n            this.bulkReset(stateManager);\n        }\n        stateManager.processUpdates(updates);\n        this.sectionLock(stateManager, subsectionIds, false);\n    };\n\n    /**\n     * Raise page level.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids to move\n     */\n    fmtPageRaise = async function(stateManager, sectionIds) {\n        if (sectionIds.length != 1) {\n            throw new Error(`Mutation fmtPageRaise requires exactly one section ID.`);\n        }\n        const course = stateManager.get('course');\n        const section = stateManager.get(\"section\", sectionIds[0]);\n        if (section.levelsan != 1) {\n            throw new Error(`Mutation fmtPageRaise requires section level 1.`);\n        }\n        const targetSectionId = section.parentid;\n        // ADDED.\n        let subsectionIds = [];\n        for (const sectionId of sectionIds) {\n            const section = stateManager.get(\"section\", sectionId);\n            for (let subsection = section;\n                    subsection && (subsection.id == section.id || subsection.levelsan > section.levelsan);\n                    subsection = (course.sectionlist.length > subsection.number + 1) ?\n                        stateManager.get(\"section\", course.sectionlist[subsection.number + 1]) : null) {\n                subsectionIds.push(subsection.id);\n            }\n        }\n        // END ADDED.\n        this.sectionLock(stateManager, subsectionIds, true);\n        const updates = await this._callEditWebservice(\n            'section_move_after', course.id, sectionIds, targetSectionId, section.levelsan - 1\n        );\n        this.bulkReset(stateManager);\n        stateManager.processUpdates(updates);\n        this.sectionLock(stateManager, subsectionIds, false);\n    };\n\n    /**\n     * Lower page level.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids to move\n     */\n    fmtPageLower = async function(stateManager, sectionIds) {\n        if (sectionIds.length != 1) {\n            throw new Error(`Mutation fmtPageLower requires exactly one section ID.`);\n        }\n        const course = stateManager.get('course');\n        const section = stateManager.get(\"section\", sectionIds[0]);\n        if (section.levelsan != 0) {\n            throw new Error(`Mutation fmtPageLower requires section level 0.`);\n        }\n        const targetSectionId = section.prevupid;\n        // ADDED.\n        let subsectionIds = [];\n        for (const sectionId of sectionIds) {\n            const section = stateManager.get(\"section\", sectionId);\n            for (let subsection = section;\n                    subsection && (subsection.id == section.id || subsection.levelsan > section.levelsan);\n                    subsection = (course.sectionlist.length > subsection.number + 1) ?\n                        stateManager.get(\"section\", course.sectionlist[subsection.number + 1]) : null) {\n                subsectionIds.push(subsection.id);\n            }\n        }\n        // END ADDED.\n        this.sectionLock(stateManager, subsectionIds, true);\n        const updates = await this._callEditWebservice(\n            'fmt_section_move_into', course.id, sectionIds, targetSectionId, section.levelsan + 1\n        );\n        this.bulkReset(stateManager);\n        stateManager.processUpdates(updates);\n        this.sectionLock(stateManager, subsectionIds, false);\n    };\n\n}\n\nexport const init = () => {\n    const courseEditor = getCurrentCourseEditor();\n    // Some plugin (activity or block) may have their own mutations already registered.\n    // This is why we use addMutations instead of setMutations here.\n    courseEditor.addMutations(new MultitopicMutations());\n    // Add direct mutation content actions.\n    CourseActions.addActions({\n        fmtPageRaise: 'fmtPageRaise',\n        fmtPageLower: 'fmtPageLower',\n    });\n};\n"],"names":["MultitopicMutations","DefaultMutations","async","stateManager","sectionIds","targetSectionId","Error","course","get","subsectionIds","sectionId","section","subsection","id","levelsan","sectionlist","length","number","push","sectionLock","updates","this","_callEditWebservice","bulkReset","processUpdates","parentid","prevupid","action","courseId","ids","targetCmId","args","courseid","targetsectionid","undefined","targetcmid","ajaxresult","ajax","call","methodname","JSON","parse","addMutations","addActions","fmtPageRaise","fmtPageLower"],"mappings":"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"}