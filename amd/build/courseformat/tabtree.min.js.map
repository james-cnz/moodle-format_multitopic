{"version":3,"file":"tabtree.min.js","sources":["../../src/courseformat/tabtree.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {BaseComponent} from 'core/reactive';\nimport {getCurrentCourseEditor} from 'core_courseformat/courseeditor';\nimport Templates from 'core/templates';\n\n\n/**\n * Course section tabs updater.\n *\n * @module     format_multitopic/courseformat/tabtree\n * @class      format_multitopic/courseformat/tabtree\n * @copyright  2022 Jeremy FitzPatrick and Te WƒÅnanga o Aotearoa\n * @copyright  based on work by 2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nexport default class Component extends BaseComponent {\n\n    /**\n     * Constructor hook.\n     */\n    create() {\n        // Optional component name for debugging.\n        this.name = 'coursetabs';\n        // Default query selectors.\n        this.selectors = {\n            TAB: `ul:first-of-type li`,\n            CHILDTAB: `ul:nth-child(2) li`\n        };\n        // Default classes\n        this.classes = {\n            ACTIVETAB: 'active'\n        };\n        // Objects to keep tabs on the tabs\n        this.tabs = {};\n        this.childtabs = {};\n        this.activetab = [null, null];\n    }\n\n    getWatchers() {\n        return [\n            // Sections sorting.\n            {watch: `course.sectionlist:updated`, handler: this._refreshCourseSectionTabs},\n        ];\n    }\n\n    static init(target) {\n        return new Component({\n            element: document.getElementById(target),\n            reactive: getCurrentCourseEditor()\n        });\n    }\n\n    /**\n     * Initial state ready method.\n     *\n     */\n    stateReady() {\n        // Get tab elements.\n        const tabs = this.getElements(this.selectors.TAB);\n        for (let i = 0; i < tabs.length - 1; i++) { // Don't count last \"add section\" tab.\n            let tab = tabs.item(i);\n            let id = tab.querySelector(\"a div\").dataset.itemid;\n            let classes = tab.querySelector(\"a\").classList.value;\n            this.tabs[id] = tab;\n            if (classes.indexOf(this.classes.ACTIVETAB) !== -1) {\n                this.activetab[0] = id;\n                this.activetab[1] = id;\n            }\n        }\n\n        const childtabs = this.getElements(this.selectors.CHILDTAB);\n        for (let i = 0; i < childtabs.length - 1; i++) { // Don't count last \"add section\" tab.\n            let tab = childtabs.item(i);\n            let id = tab.querySelector(\"a div\").dataset.itemid;\n            let classes = tab.querySelector(\"a\").classList.value;\n            this.childtabs[id] = tab;\n            if (classes.indexOf(this.classes.ACTIVETAB) !== -1) {\n                this.activetab[1] = id;\n            }\n        }\n    }\n\n    /**\n     * Refresh the section tabs.\n     *\n     * @param {object} param\n     * @param {Object} param.element\n     */\n    _refreshCourseSectionTabs({element}) {\n        // Change the active top-level tab, if necessary.\n        const activeTab1 = this.reactive.get('section', this.activetab[1]);\n        let newActiveTab0id = (activeTab1.levelsan >= 1) ? activeTab1.parentid : activeTab1.id;\n        if (newActiveTab0id != this.activetab[0]) {\n            let section = this.reactive.stateManager.state.section.get(this.activetab[0]);\n            let anchor = this.element.querySelector('ul:first-of-type div[data-itemid=\"' + this.activetab[0] + '\"]').parentElement;\n            anchor.classList.remove(\"active\");\n            anchor.href = section.sectionurl.replace(\"&amp;\", \"&\");\n            this.activetab[0] = newActiveTab0id;\n            anchor = this.element.querySelector('ul:first-of-type div[data-itemid=\"' + this.activetab[0] + '\"]').parentElement;\n            anchor.classList.add(\"active\");\n            anchor.removeAttribute(\"href\");\n        }\n\n        // Do things that make the first row tabs match firstsectionlist.\n        const toptabslist = element.firstsectionlist ?? [];\n        const childtabslist = element.secondsectionlist ?? [];\n        let toptabs = this.element.querySelector('ul:first-of-type');\n        this._fixOrder(toptabs, toptabslist, this.tabs, childtabslist[this.activetab[0]].length > 1);\n\n        // And the second row tabs match secondsectionlist.\n        let childtabs = this.element.querySelector('ul:nth-of-type(2)');\n        if (childtabs) {\n            this._fixOrder(childtabs, childtabslist[this.activetab[0]], this.childtabs, false);\n        }\n    }\n\n    /**\n     * Fix/reorder the section or cms order.\n     *\n     * @param {Element} container the HTML element to reorder.\n     * @param {Array} neworder an array with the ids order\n     * @param {Array} allitems the list of html elements that can be placed in the container\n     * @param {boolean} hassubtree\n     */\n    _fixOrder(container, neworder, allitems, hassubtree) {\n\n        // Empty lists should not be visible.\n        if (!neworder.length) {\n            container.classList.add('hidden');\n            container.innerHTML = '';\n            return;\n        }\n\n        // Grant the list is visible (in case it was empty).\n        container.classList.remove('hidden');\n\n        // Move the elements in order at the beginning of the list.\n        neworder.forEach((itemid, index) => {\n            const section = this.reactive.stateManager.state.section.get(itemid);\n            const visible = (section.visible && section.available || section.section == 0)\n                && (neworder.length > 1 || hassubtree);\n            if (allitems[itemid] === undefined) {\n                // If we don't have an item, create it from the course index.\n                let selecta = \"[data-id='\" + itemid + \"']\";\n                let ciElement = document.querySelector(selecta);\n                let ciLink = ciElement.querySelector(\" a.courseindex-link\");\n                let data = {\n                    \"active\": 0,\n                    \"inactive\": 0,\n                    \"link\": [{\n                    \"link\": ciLink.getAttribute(\"href\")\n                }],\n                    \"title\": ciLink.innerHTML,\n                    \"text\": '<div class=\"tab_content' + (visible ? '' : ' dimmed')\n                        + '\" data-itemid=\"' + section.id + '\">' + section.title + '</div>'\n                };\n                let tab = document.createElement(\"li\");\n                allitems[itemid] = tab;\n                container.insertBefore(tab, container.lastElementChild);\n                Templates.render(\"format_multitopic/courseformat/tab\", data).done(function(html) {\n                    Templates.replaceNode(item, html);\n                });\n            }\n            const item = allitems[itemid];\n            // Update visibility\n            const content = item.querySelector(\"div.tab_content\");\n            if (content && content.classList.contains(\"dimmed\") == visible) {\n                if (visible) {\n                    content.classList.remove(\"dimmed\");\n                } else {\n                    content.classList.add(\"dimmed\");\n                }\n            }\n\n            // Get the current element at that position.\n            const currentitem = container.children[index];\n            if (currentitem === undefined) {\n                container.append(item);\n                return;\n            }\n            if (currentitem !== item) {\n                container.insertBefore(item, currentitem);\n            }\n        });\n        // Remove the remaining elements.\n        // But we don't want the \"Add\" blown away.\n        while (container.children.length > neworder.length + 1) {\n                container.removeChild(container.lastElementChild.previousSibling);\n        }\n\n    }\n\n}"],"names":["Component","BaseComponent","create","name","selectors","TAB","CHILDTAB","classes","ACTIVETAB","tabs","childtabs","activetab","getWatchers","watch","handler","this","_refreshCourseSectionTabs","target","element","document","getElementById","reactive","stateReady","getElements","i","length","tab","item","id","querySelector","dataset","itemid","classList","value","indexOf","activeTab1","get","newActiveTab0id","levelsan","parentid","section","stateManager","state","anchor","parentElement","remove","href","sectionurl","replace","add","removeAttribute","toptabslist","firstsectionlist","childtabslist","secondsectionlist","toptabs","_fixOrder","container","neworder","allitems","hassubtree","innerHTML","forEach","index","visible","available","undefined","selecta","ciLink","data","getAttribute","title","createElement","insertBefore","lastElementChild","render","done","html","replaceNode","content","contains","currentitem","children","append","removeChild","previousSibling"],"mappings":"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"}